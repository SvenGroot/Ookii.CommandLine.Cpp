# Shell commands

Ookii.CommandLine provides the ability to create an application that has more than one function,
invoked using a subcommand.

An application like this will have a command like like `./program <command> [args...]`, where the
exact arguments will be different for every command. Rather than having each command in their own
executable, this allows you to group related functionality in a single binary.

Think for example of the Windows `net` command, which provides many different operations through the
same executable, like `net use` or `net start`. Or, in Linux there's the `systemctl` application,
which provides commands like `systemctl start` or `systemctl status`.

In Ookii.CommandLine, these kinds of subcommands are called _shell commands_, and the library allows
you to easily create an application like this.

## Defining shell commands

To create a command for your application, you define a class that derives from `ookii::shell_command`.

This class must have a constructor that takes a reference to a `parser_builder`, which you must
use to specify the arguments for your command. This `parser_builder` will have been initialized with
the name and description of your command, and a `case_sensitive()` and `locale()`
value that match the `shell_command_manager`'s (see below).

> Note: do not call `build()` on the `parser_builder`; `shell_command_manager` will do that for
> you.

You then override the `run()` method to implement your command. The return value of the `run()`
method should typically be used as the exit code of the application.

Here is a simple example of a command with a single argument:

```c++
class my_command : public ookii::shell_command
{
public:
    my_command(builder_type &builder)
    {
        builder.add_argumment(_value, "Value");
    }

    virtual int run() override
    {
        std::cout << "The value is: " << _value << std::endl;
        return 0;
    }

private:
    int _value{};
};
```

### Registering commands

The preferred way to instantiate and use shell commands is using the `ookii::shell_command_manager`
class. Before you can do so, however, you must tell it which commands exist, by registering them
using the `add_command()` method. This method takes as a template argument the type of shell command
class you wish to register.

Like the `parser_builder` methods, calls to `add_command()` can be chained together.

```c++
ookii::shell_command_manager manager{argv[0]};
manager
    .add_command<my_command>()
    .add_command<another_command>();
```

The argument to the `shell_command_manager` constructor is the application name, which you once
again can typically derive from the first element in `argv`.

### Case sensitive command names

By default the `shell_command_manager` treats command names as case insensitive. So, a command
named "foo" could be invoked using "Foo" or "FOO" or any variation.

Pass `true` to the `case_sensitive` argument of the `shell_command_manager` constructor to use
case sensitive command names instead. In that case, you can also define commands whose names differ
only by case (soo "foo" and "FOO" can be different commands).

Case sensitivity of the argument names for the commands will match the case sensitivity of the
command names by default, but this can be overridden by using the `parser_builder::case_sensitive()`
method in the constructor of a command.

## Using shell commands

To use a shell command, you must first determine the command the user wishes to invoke, typically by
checking the first argument to your application (`argv[1]`, since `argv[0]` holds the application
name). You can then use `get_command()` method to get information about the shell command,
instantiate it using `shell_command_info::create()`, and then invoke the `run()` method.

The `shell_command_manager` provides helpers that do this for you, handling errors and printing
usage help as required. The `create_command()` method instantiates the class, parses the
arguments, and returns the instance if successful.

Even easier is the `run_command()` method, which does the same thing but also invokes `run()`
and returns the return value of `run()`, or an error code if the command couldn't be created.

This means that running a command can be as easy as this (after the registration code above):

```c++
return manager.run_command(argc, argv);
```

This takes care of everything for you. If no command was specified, or the specified command could
not be found, it will write a list of commands and their descriptions to the console. If the command
was found but an error occurred parsing its arguments, it will print the error and usage help for
the command's arguments. Only if parsing is successful will the `run()` method be called. In this
sample, the command's exit code is then returned from `main()`.

The usage help generated by `shell_command_manager` can be customized with the `shell_command_usage_options`
class. This class derives from `usage_options`, and adds some additional options to control the
format of the list of commands. The `create_command()` and `run_command()` overloads take this as
their final parameter.

## Shell command names and descriptions

There are three ways the name of a command is determined when you call `add_command<T>()`.

1. If the name argument of `add_command<T>()` is a non-empty string, it's used as the name.

    ```c++
    manager.add_command<my_command>("name");
    ```

2. If the name argument is omitted or an empty string, the compiler looks for a static method called
   `name()` on the shell command class, and if found, calls it to get the name.
3. If no such method exists, the type name (without the namespace prefix) is used as the name.

The description is determined in a similar way:

1. If the description argument of `add_command<T>()` is a non-empty string, it's used as the
   description.

    ```c++
    manager.add_command<my_command>("name", "The description of the command.");
    ```

2. If the description argument is omitted or an empty string, the compiler looks for a static method
   called `description()` on the shell command class, and if found, calls it to get the description.
3. If no such method exists, the description will be empty.

Here is an example of a class that uses the static methods to set its name and description:

```c++
class my_command : public ookii::shell_command
{
public:
    my_command(builder_type &builder)
    {
        builder.add_argumment(_value, "Value");
    }

    virtual int run() override
    {
        std::cout << _value << std::endl;
        return 0;
    }

    static std::string name()
    {
        return "name";
    }

    static std::string description()
    {
        return "The description of the command.";
    }

private:
    int _value{};
};
```

This allows you to keep the metadata of your command with the command's class, rather than having
to specify it in a separate location.

## Code-generation scripts

Just like a stand-alone parser, it's possible to generate the argument parser for a shell command
class by adding special annotations and using the provided [code-generation scripts](Scripts.md),
which is what we'll cover next.
